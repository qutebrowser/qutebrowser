#!/usr/bin/env python3

# Copyright 2017 Chris Braun (cryzed) <cryzed@googlemail.com>
#
# This file is part of qutebrowser.
#
# qutebrowser is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# qutebrowser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with qutebrowser.  If not, see <https://www.gnu.org/licenses/>.

"""
Insert login information using pass and a dmenu-compatible application (e.g. dmenu, rofi -dmenu, ...). A short
demonstration can be seen here: https://i.imgur.com/KN3XuZP.gif.
"""

USAGE = """The domain of the site has to appear as a segment in the pass path,
for example: "github.com/cryzed" or "websites/github.com". Alternatively the
parameter `--unfiltered` may be used to get a list of all passwords. How the
username and password are determined is freely configurable using the CLI
arguments. As an example, if you instead store the username as part of the
secret (and use a site's name as filename), instead of the default configuration,
use `--username-target secret` and `--username-pattern "username: (.+)"`.

The login information is inserted by emulating key events using qutebrowser's
fake-key command in this manner: [USERNAME]<Tab>[PASSWORD], which is compatible
with almost all login forms.

If you use gopass with multiple mounts, use the CLI switch --mode gopass to switch to gopass mode.

Suggested bindings similar to Uzbl's `formfiller` script:

    config.bind('<z><l>', 'spawn --userscript qute-pass')
    config.bind('<z><u><l>', 'spawn --userscript qute-pass --username-only')
    config.bind('<z><p><l>', 'spawn --userscript qute-pass --password-only')
    config.bind('<z><o><l>', 'spawn --userscript qute-pass --otp-only')
"""

EPILOG = """Dependencies: tldextract (Python 3 module), pass, pass-otp (optional).

WARNING: The login details are viewable as plaintext in qutebrowser's debug log (qute://log) and might be shared if
you decide to submit a crash report!"""

import argparse
import enum
import fnmatch
import functools
import os
import re
import shlex
import subprocess
import sys

import tldextract


def expanded_path(path):
    # Expand potential ~ in paths, since this script won't be called from a shell that does it for us
    expanded = os.path.expanduser(path)
    # Add trailing slash if not present
    return os.path.join(expanded, '')


argument_parser = argparse.ArgumentParser(description=__doc__, usage=USAGE, epilog=EPILOG)
argument_parser.add_argument('url', nargs='?', default=os.getenv('QUTE_URL'))
argument_parser.add_argument('--password-store', '-p', default=None,
                             help='Path to your password-store', type=expanded_path)
argument_parser.add_argument('--mode', '-M', choices=['pass', 'gopass'], default="pass",
                             help='Select mode [gopass] to use gopass instead of the standard pass.')
argument_parser.add_argument('--prefix', type=str,
                             help='Search only the given subfolder of the store (only used in gopass-mode)')
argument_parser.add_argument('--username-pattern', '-u', default=r'.*/(.+)',
                             help='Regular expression that matches the username')
argument_parser.add_argument('--username-target', '-U', choices=['path', 'secret'], default='path',
                             help='The target for the username regular expression')
argument_parser.add_argument('--password-pattern', '-P', default=r'(.*)',
                             help='Regular expression that matches the password')
argument_parser.add_argument('--dmenu-invocation', '-d', default='rofi -dmenu',
                             help='Invocation used to execute a dmenu-provider')
argument_parser.add_argument('--no-insert-mode', '-n', dest='insert_mode', action='store_false',
                             help="Don't automatically enter insert mode")
argument_parser.add_argument('--io-encoding', '-i', default='UTF-8',
                             help='Encoding used to communicate with subprocesses')
argument_parser.add_argument('--merge-candidates', '-m', action='store_true',
                             help='Merge pass candidates for fully-qualified and registered domain name')
argument_parser.add_argument('--extra-url-suffixes', '-s', default='',
                             help='Comma-separated string containing extra suffixes (e.g local)')
argument_parser.add_argument('--unfiltered', dest='unfiltered', action='store_true',
                             help='Show an unfiltered selection of all passwords in the store')
argument_parser.add_argument('--always-show-selection', dest='always_show_selection', action='store_true',
                             help='Always show selection, even if there is only a single match')
group = argument_parser.add_mutually_exclusive_group()
group.add_argument('--username-only', '-e', action='store_true', help='Only insert username')
group.add_argument('--password-only', '-w', action='store_true', help='Only insert password')
group.add_argument('--otp-only', '-o', action='store_true', help='Only insert OTP code')

stderr = functools.partial(print, file=sys.stderr)


class ExitCodes(enum.IntEnum):
    SUCCESS = 0
    FAILURE = 1
    # 1 is automatically used if Python throws an exception
    NO_PASS_CANDIDATES = 2
    COULD_NOT_MATCH_USERNAME = 3
    COULD_NOT_MATCH_PASSWORD = 4


class CouldNotMatchUsername(Exception):
    pass


class PassExecutionFailed(Exception):
    pass


class CouldNotMatchPassword(Exception):
    pass


def qute_command(command):
    with open(os.environ['QUTE_FIFO'], 'w') as fifo:
        fifo.write(command + '\n')
        fifo.flush()


def find_pass_candidates(domain, unfiltered=False):
    candidates = []

    if arguments.mode == "gopass":
        gopass_args = ["list", "--flat"]
        if arguments.prefix:
            gopass_args.append(arguments.prefix)

        for password in _run_pass(gopass_args).splitlines():
            if unfiltered or domain in password:
                candidates.append(password)
    else:
        for path, directories, file_names in os.walk(arguments.password_store, followlinks=True):
            secrets = fnmatch.filter(file_names, '*.gpg')
            if not secrets:
                continue

            # Strip password store path prefix to get the relative pass path
            pass_path = path[len(arguments.password_store):]
            split_path = pass_path.split(os.path.sep)
            for secret in secrets:
                secret_base = os.path.splitext(secret)[0]
                if not unfiltered and domain not in (split_path + [secret_base]):
                    continue

                candidates.append(os.path.join(pass_path, secret_base))
    return candidates


def _run_pass(pass_arguments):
    # The executable is conveniently named after its mode [pass|gopass].
    pass_command = [arguments.mode] + pass_arguments
    env = os.environ.copy()
    env['PASSWORD_STORE_DIR'] = arguments.password_store
    process = subprocess.run(pass_command, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    err_msg = process.stderr.decode(arguments.io_encoding).strip()

    if err_msg:
        if arguments.mode == "gopass" and "initialize" in err_msg:
            # Warn the user if the error could be caused by a changed default directory.
            # See <https://github.com/gopasspw/gopass/pull/1968/commits/de4ba223422417559f36346bd51ce075e9812924>
            stderr(
                "Warning: With gopass 1.12.8, the default password store directory changed from `~/.password-store` "
                "to `~/.local/share/gopass/stores/root, and qute-pass now uses this new default. If your password "
                f"store isn't '{arguments.password_store}', specify a store with the `--password-store` argument "
                "to qute-pass, or by setting the PASSWORD_STORE_DIR environment variable."
            )
        if err_msg.startswith("Error:"):
            raise PassExecutionFailed(err_msg)
    return process.stdout.decode(arguments.io_encoding).strip()


def pass_(path):
    return _run_pass(['show', path])


def pass_otp(path):
    if arguments.mode == "gopass":
        return _run_pass(['otp', '-o', path])
    return _run_pass(['otp', path])


def dmenu(items, invocation):
    command = shlex.split(invocation)
    process = subprocess.run(command, input='\n'.join(items).encode(arguments.io_encoding), stdout=subprocess.PIPE)
    return process.stdout.decode(arguments.io_encoding).strip()


def fake_key_raw(text):
    for character in text:
        # Escape all characters by default, space requires special handling
        sequence = '" "' if character == ' ' else fr'\{character}'
        qute_command(f'fake-key {sequence}')


def extract_password(secret, pattern):
    match = re.match(pattern, secret)
    if not match:
        raise CouldNotMatchPassword("Pattern did not match target")
    try:
        return match.group(1)
    except IndexError:
        raise CouldNotMatchPassword("Pattern did not contain capture group, please use capture group. Example: (.*)")


def extract_username(target, pattern):
    match = re.search(pattern, target, re.MULTILINE)
    if not match:
        raise CouldNotMatchUsername("Pattern did not match target")
    try:
        return match.group(1)
    except IndexError:
        raise CouldNotMatchUsername("Pattern did not contain capture group, please use capture group. Example: (.*)")


def type_secret(selection):
    secret = None
    # If username-target is path and user asked for username-only, we don't need to run pass.
    # Or if using otp-only, it will run pass on its own.
    if not (arguments.username_target == 'path' and arguments.username_only) and not arguments.otp_only:
        secret = pass_(selection)
    username_target = selection if arguments.username_target == 'path' else secret

    if arguments.username_only:
        fake_key_raw(extract_username(username_target, arguments.username_pattern))
    elif arguments.password_only:
        fake_key_raw(extract_password(secret, arguments.password_pattern))
    elif arguments.otp_only:
        fake_key_raw(pass_otp(selection))
    else:
        # Enter username and password using fake-key and <Tab> (which seems to work almost universally), then switch
        # back into insert-mode, so the form can be directly submitted by hitting enter afterwards
        fake_key_raw(extract_username(username_target, arguments.username_pattern))
        qute_command('fake-key <Tab>')
        fake_key_raw(extract_password(secret, arguments.password_pattern))

    if arguments.insert_mode:
        qute_command('mode-enter insert')


def main(arguments):
    if not arguments.url:
        argument_parser.print_help()
        return ExitCodes.FAILURE

    if arguments.password_store is None:
        # `pass` and `gopass` use different default password store directories
        default = '~/.local/share/gopass/stores/root' if arguments.mode == "gopass" else '~/.password-store'
        arguments.password_store = expanded_path(os.getenv('PASSWORD_STORE_DIR', default=default))

    extractor = tldextract.TLDExtract(extra_suffixes=arguments.extra_url_suffixes.split(','))
    extract_result = extractor(arguments.url)

    # Try to find candidates using targets in the following order: fully-qualified domain name (includes subdomains),
    # the registered domain name, the IPv4 address if that's what the URL represents and finally the private domain
    # (if a non-public suffix was used).
    candidates = set()
    attempted_targets = []

    private_domain = ''
    if not extract_result.suffix:
        private_domain = ('.'.join((extract_result.subdomain, extract_result.domain))
                          if extract_result.subdomain else extract_result.domain)

    for target in filter(None, [extract_result.fqdn, extract_result.registered_domain, extract_result.ipv4, private_domain]):
        attempted_targets.append(target)
        try:
            target_candidates = find_pass_candidates(target, unfiltered=arguments.unfiltered)
        except PassExecutionFailed as e:
            stderr(f'Failed to execute {arguments.mode}, target: candidates, error: {e}')
            return ExitCodes.FAILURE

        if not target_candidates:
            continue

        candidates.update(target_candidates)
        if not arguments.merge_candidates:
            break
    else:
        if not candidates:
            stderr('No pass candidates for URL {repr(arguments.url)} found! (I tried {repr(attempted_targets)})')
            return ExitCodes.NO_PASS_CANDIDATES

    if len(candidates) == 1 and not arguments.always_show_selection:
        selection = candidates.pop()
    else:
        selection = dmenu(sorted(candidates), arguments.dmenu_invocation)

    # Nothing was selected, simply return
    if not selection:
        return ExitCodes.SUCCESS

    try:
        type_secret(selection)
    except PassExecutionFailed as e:
        stderr(f'Failed to execute {arguments.mode}, target: secret, error: {e}')
        return ExitCodes.FAILURE
    except CouldNotMatchPassword as e:
        stderr(f'Failed to match password, target: secret, error: {e}')
        return ExitCodes.COULD_NOT_MATCH_PASSWORD
    except CouldNotMatchUsername as e:
        stderr(f'Failed to match username, target: {arguments.username_target}, error: {e}')
        return ExitCodes.COULD_NOT_MATCH_USERNAME

    return ExitCodes.SUCCESS


if __name__ == '__main__':
    arguments = argument_parser.parse_args()
    sys.exit(main(arguments))
