"""This script auto-generates the `qutebrowser/config/configcontainer.py` file."""

import pathlib
import textwrap
from typing import TYPE_CHECKING, NoReturn, Union
from collections.abc import Mapping, Iterator

from qutebrowser.config import configdata
from qutebrowser.config.configdata import Option


if TYPE_CHECKING:
    from typing_extensions import assert_never
else:

    def assert_never(value) -> NoReturn:
        raise AssertionError(f"Expected code to be unreachable, but got: {repr(value)}")


NestedConfig = dict[str, Union[Option, "NestedConfig"]]


def make_nested_config(config: Mapping[str, Option]) -> NestedConfig:
    """The original configdata.yml defines nested keys using `.`s in a flat tree.

    This function returns a new dict where options are grouped and nested, e.g.
    `'auto_save.session': Option(...)` -> `{'auto_save': {'session': Option(...)}}`
    """
    result = {}
    for key, value in config.items():
        parts = key.split(".")
        current = result
        for part in parts[:-1]:
            current = current.setdefault(part, {})
        current[parts[-1]] = value
    return result


def generate_config_types(config_data: Mapping[str, Option]) -> Iterator[str]:
    """Generate the `ConfigContainer` dataclass and all nested types."""
    yield "# SPDX-FileCopyrightText: Florian Bruhin (The Compiler) <mail@qutebrowser.org>"
    yield "#"
    yield "# SPDX-License-Identifier: GPL-3.0-or-later"
    yield ""
    yield "# DO NOT EDIT THIS FILE DIRECTLY!"
    yield "# It is autogenerated by running:"
    yield "#   $ python3 scripts/dev/src2asciidoc.py"
    yield "# vim: readonly:"
    yield ""
    yield triple_quote(
        textwrap.dedent("""
            This file defines static types for the `c` variable in `config.py`.

            This is auto-generated from the `scripts/dev/generate_config_types.py` file.

            It is not intended to be used at runtime.

            Example usage:
            ```py
            from qutebrowser.api.configpy import c, config
            ```
        """).lstrip()
    )
    yield ""
    yield "# pylint: disable=line-too-long, invalid-name"
    yield ""
    yield "import re"
    yield "from dataclasses import dataclass"
    yield "from collections.abc import Mapping"
    yield "from typing import Optional, Union, Literal"
    yield ""
    yield ""

    def generate_class(
        class_name: str,
        config: NestedConfig,
        *,
        indent: str = "",
        description: 'str | None' = None,
    ) -> Iterator[str]:
        yield f"{indent}@dataclass"
        yield f"{indent}class {class_name}:"

        if description is not None:
            yield f"{indent}    {triple_quote(description)}"

        for key, value in config.items():
            if isinstance(value, Option):
                type_hint = value.typ.py_type()
                if value.default is None:
                    yield f"{indent}    {key}: Optional[{type_hint}]"
                else:
                    yield f"{indent}    {key}: {type_hint}"

                if value.description:
                    lines = value.description.split("\n")
                    description = "\n\n".join(
                        [
                            line if i == 0 else f"{indent}    {line}"
                            for i, line in enumerate(lines)
                        ]
                    )
                    if not description.endswith("\n") and len(lines) > 1:
                        description += f"\n{indent}    "

                    yield f"{indent}    {triple_quote(description)}\n"
            elif isinstance(value, dict):
                nested_class_name = "_" + snake_to_camel(key)
                yield f"{indent}    {key}: '{nested_class_name}'"
                yield from generate_class(
                    nested_class_name, value, indent=indent + "    "
                )
            else:
                assert_never(value)

    nested_config = make_nested_config(config_data)
    yield from generate_class(
        "ConfigContainer",
        nested_config,
        description="Type for the `c` variable in `config.py`.",
    )


def snake_to_camel(name: str) -> str:
    return "".join(word.capitalize() for word in name.split("_"))


def triple_quote(v: str) -> str:
    """surround the given string with trible double quotes."""
    # some option descriptions use `\+` which isn't a valid escape sequence
    # in python docstrings, so just escape it.
    return '"""' + v.replace(r"\+", r"\\+") + '"""'


def main():
    configdata.init()

    generated_code = "\n".join(generate_config_types(configdata.DATA))

    output_file = (
        pathlib.Path(__file__).parent.parent.parent
        / "qutebrowser"
        / "config"
        / "configcontainer_types.py"
    )
    output_file.write_text(generated_code)

    print(f"Config types have been written to {output_file.resolve()}")


if __name__ == "__main__":
    main()
