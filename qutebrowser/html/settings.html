{% extends "base.html" %}

{% block script %}
var cset = function(option, value) {
  // FIXME:conf we might want some error handling here?
  var url = "qute://user:{{csrf_token}}@settings/set"
  url += "?option=" + encodeURIComponent(option);
  url += "&value=" + encodeURIComponent(value);
  var xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.send();
}

const search = debounce(() => searchOption())

// Create a delay while the user types
const debounce = (func, timeout=200) => {
  let timer;
  return () => {
    clearTimeout(timer)
    timer = setTimeout(() => { func.apply(this) }, timeout)
  }
}

/* First sort the options' names back into alphabetical order. Make them invisible.
Filter first by name, then by short description and finally by long description.
Display them in this order.*/
const searchOption = () => {
  const searchQuery = document.getElementById("searchbox").value.toLowerCase()
  const table = document.getElementById("options-table")
  const filtered = new Set()

  const optionsArray = Array.from(document.querySelectorAll(".options"))

  // Sort options' names into alphabetical order
  sortOptions(optionsArray)
  // Make each option invisible
  optionsArray.forEach(option => option.classList.add("is-hidden"))

  const filterByName = (option) => {
    const setting = option.childNodes[3]
    const name = setting.childNodes[1].textContent.toLowerCase()

    return name.includes(searchQuery)
  }

  const filterByShortDesc = (option) => {
    const id = option.id
    const shortDesc = `short-desc-${id}`
    const shortDescElement = document.getElementById(shortDesc).textContent.toLowerCase()

    const isIncluded = shortDescElement.includes(searchQuery) && !filtered.has(option)

    return isIncluded
  }

  const filterByLongDesc = (option) => {
    const id = option.id
    const londDesc = `long-desc-${id}`
    const longDescElement = document.getElementById(londDesc)?.textContent.toLowerCase()
    const isIncluded = longDescElement?.includes(searchQuery) &&
			            !filtered.has(option)

    return isIncluded
  }

  // Filter options by name, short description and long description
  // and add them to the filtered set
  const filteredByName = optionsArray.filter(filterByName)
  filteredByName.forEach(item => filtered.add(item))
  const filteredByShortDesc = optionsArray.filter(filterByShortDesc)
  filteredByShortDesc.forEach(item => filtered.add(item))
  const filteredByLongDesc = optionsArray.filter(filterByLongDesc)
  filteredByLongDesc.forEach(item => filtered.add(item))

  const filteredFragment = new DocumentFragment()

  // Move the filtered options into a fragment and append them at the end of the table,
  // while the other options are hidden
  filtered.forEach(option => addToFragment(option, filteredFragment))
  table.append(filteredFragment)
}

// Sort options into alphabetical order
const sortOptions = (options) => {
  options.sort((a, b) => {
    const settingA = a.childNodes[3]
    const nameA = settingA.childNodes[1].textContent.toLowerCase()
    const settingB = b.childNodes[3]
    const nameB = settingB.childNodes[1].textContent.toLowerCase()

    if (nameA < nameB) {
      return -1;
    }
    if (nameA > nameB) {
      return 1;
    }
    return 0;
  })
}

// Make option visible again and append it to the fragment
const addToFragment = (option, fragment) => {
  option.classList.remove("is-hidden")
  fragment.append(option)
}
{% endblock %}

{% block style %}
body {
    margin: 0 8px 8px;
}
table {
    border-spacing: 10px;
}

tbody tr:nth-child(odd) {
    background: #eaf4fb;
}

pre {
    margin: 2px;
}

th {
    padding: 10px;
    border-radius: 5px;
    background: #a6dfff;
    text-align: left;
    font-weight: normal;
    font-size: 1.5rem;
    color: #084c88;
}

td {
    padding: 5px 5px;
}

th pre {
    color: grey;
    text-align: left;
}

input {
    padding: 8px;
    width: 98%;
    box-sizing: border-box;
    border-radius: 4px;
    border: 1px solid #01cdd0;
    font-size: 0.9rem;
    font-family: DejaVu, serif;
}

input:focus {
    outline: none;
    border: 2px solid #7a589ea6;
}

input[type="radio"] {
    position: absolute; /* Positions the radio button relative to the edges of its containing element */
    -webkit-appearance: none; /* Removes its native styling */
    width: min-content;
    margin: 0;
    border: none;
    cursor: pointer;
}

label {
    cursor: pointer;
    margin-bottom: 2px;
    padding: 5px 10px;
    border-radius: 5px;
    background-color: #dddddd;
    color: #666666;
}

input[type="radio"]:checked + label {
    background-color: #a6dfff;
    color: #084c88;
}

.radio-button {
    position: relative; /* The absolutely positioned element inside this tag (the radio button) gets positioned relative to it. */
    display: inline-flex;
    margin: 3px 1px;
}

.search {
    position: sticky;
    top: 0;
    z-index: 1;
    padding-top: 8px;
    background-color: white;
}

input[type="search"] {
    margin-left: 10px;
    width: 99%;
    font-size: 1rem;
}

.setting {
    width: 60%;
}

.value {
    width: 25%;
    text-align: center;
}

.valid-value {
    text-align: center;
}

.noscript, .noscript-text {
    color: red;
}

.noscript-text {
    margin-bottom: 5cm;
}

.option-description {
    margin: .5ex 0;
    color: #635d5dcf;
    font-size: 80%;
    font-style: italic;
}

.option-description p {
    margin: 0;
}

.long-description {
    white-space: pre-line;
}

details summary > * {
    display: inline;
}

details[open] .details {
    display: none;
}

summary {
    margin: .5ex 0;
    width: fit-content;
    color: #1887c5;
    outline: none;
    font-size: 105%;
    cursor: pointer;
}

summary .short-description {
    color: #635d5dcf;
}

summary::selection {
    background-color: inherit;
}

.is-hidden {
    visibility: collapse;
}
{% endblock %}

{% block content %}
<noscript><h1 class="noscript">View Only</h1><p class="noscript-text">Changing settings requires javascript to be enabled!</p></noscript>
<div class="search">
  <input type="search" id="searchbox" autofocus autocomplete="off" placeholder="Search setting" onkeyup="search()">
</div>
<table>
  <tbody id="options-table">
    <tr>
        <th>Setting</th>
        <th>Value</th>
    </tr>
  {% for option in configdata.DATA.values()|sort(attribute='name') if not option.no_autoconfig %}
    <tr class="options" id="{{ option.name }}">
      {% set loopIndex = loop.index0 %}
      <!-- FIXME: convert to string properly -->
      <td class="setting">
	<span id="name-{{ option.name}}">{{ option.name }}</span>
        {% if option.description %}
          {% set description = option.description.split('\n', 1) %}
          <div class="option-description">
            {% if description|length > 1 %}
              <details>
                <summary>
		  <p id="short-desc-{{ option.name }}" class="short-description">{{ description[0]|e }}</p>
                  <span class="details">Details</span>
                </summary>
		<p id="long-desc-{{ option.name }}" class="long-description">{{ description[1]|e }}</p>
              </details>
            {% else %}
              <p id="short-desc-{{ option.name }}" class="short-description">{{ description[0]|e }}</p>
            {% endif %}
          </div>
        {% endif %}
      </td>
      {% set valid_values = option.typ.valid_values %}
      {% if valid_values is not none and not valid_values.others_permitted %}
        <td class="valid-value">
          {% for value in valid_values.values %}
            <div class="radio-button">
              <input type="radio" id="input-{{ option.name }}-{{ loop.index0 }}"
                name="{{ option.name }}" value="{{ value }}"
                onclick="cset('{{ option.name }}', this.value)"
                {% if confget(option.name) == value %}
                  checked
                {% endif %}>
              <label for="input-{{ option.name }}-{{ loop.index0 }}">
                {{ value }}
              </label>
              </div>
          {% endfor %}
        </td>
      {% else %}
        <td class="value">
          <input type="text"
            id="input-{{ option.name }}"
            onblur="cset('{{ option.name }}', this.value)"
            value="{{ confget(option.name) }}">
          </input>
        </td>
      {% endif %}
    </tr>
  {% endfor %}
  </tbody>
</table>

{% endblock %}
